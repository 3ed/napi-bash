#!/bin/bash
declare -r VERSION="0.40"
declare -r config="${XDG_CONFIG_HOME:-"${HOME}/.config"}/napi-bash/config"

subfmt_supported=("fab=txt" "microdvd=sub" "mpl2=mpl" "subviewer=sub" "subrip=srt" "tmplayer=txt")

subcp_conv=""
subfmt_conv=""
subeol_conv=""

subext="txt"
subext_autodetect=nie
suboverwrite=nie
subskipifexist=nie
colors=tak
videoext='^(3gp|avi|asf|divx|m4v|mkv|mov|mp4|mpe|mpeg|mpg|ogg|ogv|rmvb|wmv|qt)$'
DLAGENT="curl -fLsS --retry 3 --retry-delay 3 -o %o %u"
msg_raport="Łącznie pobranych napisów: %b%d/%a%B"
msg_status[0]="%2%bPobrano%R dla %i%f"
msg_status[1]="%1%bBrak napisów%R dla %i%f"
msg_status[2]="%1Brak uprawnień do zapisu w folderze z plikiem: %f"
msg_status[3]="%1Niewystarczająca ilość wolnego miejsca na urządzeniu z plikiem: %f"
msg_status[100]="%1Niepowiodła sie detekcja formatu napisów dla: %f"
msg_status[101]="%1Niepowiodło się konwertowanie formatu napisów dla: %f"
msg_status[200]="%1Zdalny serwer zwrócił: Przerwa techniczna..."
msg_status[254]="%1DLAGENT nie zawiera tagu %o dla pliku wyjściowego.."
msg_status[255]="%1Pobieranie pliku z napisami nie powiodło się, problemy z połączeniem?"
msg_gui_disabled_array=(0 1)
msg_cli_disabled_array=()
raport_gui_enabled=tak
raport_cli_enabled=tak
gui_int_warn=tak

gui_msg_fmt="gui_xml"
cli_msg_fmt="cli_esc"
gui_raport_fmt="gui_xml"
cli_raport_fmt="cli_esc"

gui_msg() {
  # 1 = type
  # 2 = msg
  if [ "$1" = "raport" ]; then
    notify-send -c "transfer.complite" -t 5000 -i "text-x-generic" "napi-bash" "$2"
  elif [ "$1" = "0" ]; then
    notify-send -c "transfer" -t 5000 -i "info" "napi-bash" "$2"
  else
    notify-send -c "transfer.error" -t 5000 -i "dialog-warning" "napi-bash: problem" "$2"
  fi
}

custom_raport() {
  return 1
}


#-------------------------------------------------------------------------------
#  Ładowanie konfiguracji..
#-------------------------------------------------------------------------------

[ -f "$config" -a -r "$config" ] && . "$config"

#-------------------------------------------------------------------------------
#  Podstawowe funkcje..
#-------------------------------------------------------------------------------
msg() {
  __print "0;32;1" "==>" "0;1" "$1"
}
msg2() {
  __print "0;34" "  -->" "0" "$1"
}

info() {
  __print "0;35;1" "Info:" "0" "$1"
  return 1
}
warn() {
  __print "0;33;1" "Uwaga:" "0" "$1" | to_stderr
  test -n "$DISPLAY" && enabled "$gui_int_warn" && gui_msg "warn" "$1" &> /dev/null &
  return 1
}
error() {
  __print "0;31;1" "Błąd:" "0" "$1" | to_stderr
  test -n "$DISPLAY" && gui_msg "error" "$1" &> /dev/null &
  return 1
}
__print() {
  if enabled "$colors"; then
    printf "\e[%sm%s\e[%sm %s...\e[0m\n" "$@"
  else
    printf "%s %s...\n" "$2" "$4"
  fi
}

enabled() {
  case "${1,,}" in
    0|-|f*|n*|wy*|of*|"") false
  esac
}

to_stderr() {
  if enabled "$DEBUG"; then
    cat
  else
    cat >&2
  fi
}

usage() {
  cat << EOF
Napi-bash wersja $VERSION | 3ED <krzysztof1987@gmail.com>

Użycie:
  napi-bash [opcje] <plik/folder> [kolejne pliki/foldery]
  napi-bash <-h|--help>

Opcje:
  -o=<bool>, --suboverwrite=<bool>, --(no-)suboverwrite
      Nadpisuj pliki (ustawione: $suboverwrite)

  -s=<bool>, --skipifexist=<bool>, --(no-)skipifexist
      Pomijaj pobrane (ustawione: $subskipifexist)

  -c=<bool>, --colors=<bool>, --(no-)colors
      Używaj kolorów (ustawione: $colors)

  -x=<tekst>, --subext=<tekst>
      Rozszerzenie pliku (ustawione: "$subext").

  -X=<bool>, --subext-autodetect=<bool>, --(no-)subext-autodetect
      Przeprowadzić autodetekcji (ustawione: $subext_autodetect).

  -F=<tekst>, --subfmt-conv=<tekst>
      Format napisów. Puste by wyłączyć. (ustawione: "$subfmt_conv")

  -C=<tekst>, --subcp-conv=<tekst>
      Konwerowanie strony kodowej napisów. Puste by wyłączyć.
      (ustawione: "$subcp_conv")

  -E=<tekst>, --subeol-conv=<tekst>
      Konwertowanie typu oznaczenia końca linii. Puste by
      wyłączyć. (ustawione: "$subeol_conv")

  -d=<od-do>, --depth=<od-do>
      Głębia przeszukiwania rekursywnego..

  --debug=<plik>
      Tryb debugowy

  -h, --help, --usage
      Wyświetl pomoc

Aby dowiedzieć się więcej, zobacz: man 1 napi-bash

Napi-bash opublikowano na licencji GPL3:
  This program comes with  ABSOLUTELY NO WARRANTY;
  This program may be  freely redistributed  under
  the terms of the GNU GPL 3. For more information
  read:   http://www.gnu.org/licenses/gpl-3.0.html
EOF

	exit 1
}

array__get_opt() {
  local opt="$1"; shift
  local i

  for i in "${@}"; do
    if [ "${i%%=*}" = "$opt" ]; then
      echo "${i#*=}"
      return 0
    fi
  done

  return 1
}

array__get_names() {
  for i in "${@}"; do
    echo "${i%%=*}"
  done
}

#-------------------------------------------------------------------------------
#  Pobieranie argumentów, wyszkiwanie i badanie plików..
#-------------------------------------------------------------------------------
get_ARGV() {
  local i opt subopt
  local -a paths

  until [ -z "$1" ]; do
    opt="$1"; shift
    case "${opt}" in
      -h|--help|--usage) usage ;;
      -o=*|--suboverwrite=*|--suboverwrite|--no-suboverwrite)
        suboverwrite="$(get_ARGV__bool "$opt")";;
      -s=*|--skipifexist=*|--skipifexist|--no-skipifexist)
        subskipifexist="$(get_ARGV__bool "$opt")";;
      -c=*|--colors=*|--colors|--no-colors)
        colors="$(get_ARGV__bool "$opt")";;
      -X=*|--subext-autodetect=*|--subext-autodetect|--no-subext-autodetect)
        subext_autodetect="$(get_ARGV__bool "$opt")";;
      -F=*|--subfmt-conv=*) subfmt_conv="${opt#*=}" ;;
      -E=*|--subeol-conv=*) subeol_conv="${opt#*=}";;
      -C=*|--subcp-conv=*) subcp_conv="${opt#*=}" ;;
      -x=*|--subext=*) subext="${opt#*=}" ;;
      -d=*|--depth=*) get_ARGV__parse_depth "${opt#*=}";;
      --debug=*)
        DEBUG=1
        local debug_log="${opt#*=}"
        exec 2>&-;
        exec 2<>"${debug_log:-"napi-bash.debug.log"}";
        set -x;
        PS4='+ [${LINENO}] ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
      ;;
      --) break ;;
      *) paths+=("$opt")
    esac
  done
  until [ -z "$1" ]; do
    paths+=("$1")
    shift
  done

  setup_iconv
  setup_subotage
  setup_7z || exit 1

  msg "Generowanie listy plików"

  # Pliki/katalogi..
  for i in "${paths[@]}"; do
    if [ -d "$i" ]; then
      get_ARGV__get_filelist_from_dir_recursively "$i"
    else
      get_ARGV__add_video_to_filelist "$i"
    fi
  done

  if [ "${#files[@]}" -le "0" ]; then
   info "Brak plików lub odrzucone przez filtr"
   exit
 else
   msg "Wyszukiwanie napisów"
 fi
}

get_ARGV__bool() {
  local left="${1%%=*}" right="${1#*=}"
  if [ "$left" = "$right" ]; then
    [[ "$left" =~ '^--no-' ]] && echo 0 || echo 1
  else
    enabled "$right" && echo 1 || echo 0
  fi
}

get_ARGV__parse_depth() {
  test -z "${1//[0-9-]/}" || return 0

  local left="${1%%-*}"
  local right="${1##*-}"

  test -n "$left" && left="-mindepth $left"
  test -n "$right" && right="-maxdepth $right"

  DEPTH="$left $right"
}

get_ARGV__bad_arg() {
  error "Brakujący lub niepoprawny argument dla '$1'"
  exit 1
}

get_ARGV__get_filelist_from_dir_recursively() {
  local i

  while IFS= read -r -u4 -d $'\0' i; do
    get_ARGV__add_video_to_filelist "$i"
  done 4< <(find "$1" $DEPTH -type f -print0)
}

get_ARGV__add_video_to_filelist() {
  test -f "$1" -a -r "$1" \
    && local ext="${1##*.}" \
    && [[ "${ext,,}" =~ $videoext ]] \
    && local size="`stat -c %s "$1"`" \
    && test "$size" -ge "10485760" \
    || return 1

  if enabled "$subskipifexist"; then
    if enabled "$subext_autodetect"; then
      # TODO "ułądnić"; Pomjać z opcją overwrite?
      for i in "${subfmt_supported[@]}"; do
        test -f "${1%.*}.${i#*=}" && return 0
      done
    fi
    test -f "${1%.*}.$subext" && return 0
  fi

  files+=("$1")
}


#-------------------------------------------------------------------------------
#  Obsłóga błędów i raporty
#-------------------------------------------------------------------------------
##### "enable" checker #####
napi_msg__enabled__gui() {
  if [ "$DISPLAY" = "" ]; then
    return 1
  fi

  if [ "$1" = "raport" ]; then
    enabled "$raport_gui_enabled" && return 0 || return 1
  fi

  local var
  for var in "${msg_gui_disabled_array[$@]}"; do
    test "$var" = "$1" -o "$var" = "@" && return 1
  done
  return 0
}
napi_msg__enabled__cli() {
  if [ "$1" = "raport" ]; then
    enabled "$raport_cli_enabled" && return 0 || return 1
  fi

  local var
  for var in "${msg_cli_disabled_array[$@]}"; do
    test "$var" = "$1" -o "$var" = "@" && return 1
  done
  return 0
}

##### main fields filler (tag replace) #####
fill_fields() {
  local ini="$1"
  local fmt="$2"
  local msg="$3"
  shift 3

  local -i c=0

  for ((c=0; $c < ${#msg}; c++)); do
    ch="${msg:c:1}"
    if [ "$ch" = "%" ]; then
      let c++
      _ini_fields_$ini "$fmt" "${msg:c:1}" "$@"
    else
      echo -n "$ch"
    fi
  done

  _fmt_fields_$fmt "R"
  echo
}

# ini fields (put the information)
_ini_fields_msg() {
  case "$2" in
    f) echo -n "${files[$3]##*/}";;
    d) echo -n "$3";;
    e) echo -n "$4";;
    %) echo -n "%";;
    *) _fmt_fields_$1 "$2"
  esac
}
_ini_fields_raport() {
  local -i d=0 n=0 a=0

  for ((a=0; $a < "${#files_stat[@]}"; a++)); do
    test "${files_stat[$a]}" = "0" && let d++ || let n++
  done

  case "$2" in
    d) echo -n "$d";;
    n) echo -n "$n";;
    a) echo -n "$a";;
    %) echo -n "%";;
    *) _fmt_fields_$1 "$2"
  esac
}

# format fields (formating output)
_fmt_fields_cli_esc() {
  enabled "$colors" || return

  case "$1" in
    [0-7]) __CLIFMT[0]=";3$1";;
    b) __CLIFMT[1]=";1";;
    i) __CLIFMT[2]=";3";;
    u) __CLIFMT[3]=";4";;
    [8-9]) unset __CLIFMT[0];;
    B) unset __CLIFMT[1];;
    I) unset __CLIFMT[2];;
    U) unset __CLIFMT[3];;
    R) unset __CLIFMT;;
    *) return;;
  esac

  echo -en "\e[0${__CLIFMT[1]}${__CLIFMT[2]}${__CLIFMT[3]}${__CLIFMT[0]}m"
}
_fmt_fields_gui_xml() {
  local c
  case "$1" in
    b|i|u)
      local canset=1
      for ((c=0; $c < ${#__GUIFMT}; c++)); do
        test "${__GUIFMT:$c:1}" = "$1" && canset=0
      done
      test "$canset" = "1" || return
      echo -n "<$1>" && __GUIFMT+="$1"
    ;;
    B|I|U)
      local stupidxml_left="" stupidxml_right="" stupidxml_tag="" canunset=0 new_GUIFMT=""
      for ((c=0; $c < ${#__GUIFMT}; c++)); do
        stupidxml_tag="${__GUIFMT:$c:1}"
        if [ "$stupidxml_tag" = "${1,}" ]; then
          canunset=1
        else
          new_GUIFMT="$stupidxml_tag"
          stupidxml_right+="<$stupidxml_tag>"
        fi
      done
      test "$canunset" = "1" || return

      for ((c=$[${#__GUIFMT}-1]; $c >= 0; c--)); do
        stupidxml_left+="</${__GUIFMT:$c:1}>"
      done

      __GUIFMT="$new_GUIFMT"

      echo -n "$stupidxml_left$stupidxml_right"
    ;;
    R)
      for ((c=$[${#__GUIFMT}-1]; $c >= 0; c--)); do
        echo -n "</${__GUIFMT:$c:1}>"
      done
      unset __GUIFMT
    ;;
    *) return;;
  esac
}

##### main message functions #####
napi_msg() {
  [ -z "$1" -o -z "$2" ] && return 1
  [ "$USERBREAK" = "1" ] && return 0

  # $1 = id pliku
  # $2 = id błędu

  local msg

  files_stat[$1]=$2

  test -n "${msg_status[$2]}" \
    && msg="${msg_status[$2]}" \
    || msg="Status #%e dla: %f"

  napi_msg_cli "$msg" "$@"
  napi_msg_gui "$msg" "$@"

  if [ "$2" -ge "100" ]; then
    test "$2" -ge "200" && exit 1
    files_warn[$1]+="${files_warn[$1]:+","}$2"
  fi

  return $2
}
napi_msg_gui() {
  napi_msg__enabled__gui "$3" || return 0
  fill_fields "msg" "$gui_msg_fmt" "$@" | gui_msg "$3" "`cat`" &
}
napi_msg_cli() {
  napi_msg__enabled__cli "$3" || return 0
  if [ "$3" = "0" ]; then
    fill_fields "msg" "$cli_msg_fmt" "$@"
  else
    fill_fields "msg" "$cli_msg_fmt" "$@" | to_stderr
  fi
}
napi_raport() {
  local msg

  if ! msg="`custom_raport`"; then
    msg="${msg_raport:-"Łącznie pobrano %i/%a napisów..."}"
  fi

  napi_raport_cli "$msg"
  napi_raport_gui "$msg"
}
napi_raport_gui() {
  napi_msg__enabled__gui "raport" || return 0
  fill_fields "raport" "$gui_raport_fmt" "$@" | gui_msg "raport" "`cat`" &
}
napi_raport_cli() {
  napi_msg__enabled__cli "raport" || return 0
  msg "Raport"
  fill_fields "raport" "$cli_raport_fmt" "$@"
}

#-------------------------------------------------------------------------------
#  Generowanie sum kontrolnych
#-------------------------------------------------------------------------------
__gen_md5_sums() {
    test -n "$1" || return 1
    local md5

  	md5="$(dd bs=10485760 count=1 if="${files[$1]}" 2> /dev/null|md5sum)" || return 1
    md5="${md5%% *}"

    test "${md5//[^0-9a-f]/}" = "$md5" \
      && test "${#md5}" = "32" \
      || return 1

    echo "$md5"
}

__gen_napi_sums() {
  # Komuś chyba się nudziło...
	if [ -z "$1" ]; then return 1; fi

	local md5 napi idx mul add n a p i s y

	md5="$1"

	idx=("14" "3"  "6"  "8"  "2")
	mul=("2"  "2"  "5"  "4"  "3")
	add=("0"  "13" "16" "11" "5")

	for p in ${!idx[*]}; do
		n="${add[p]}"
		a="${mul[p]}"
		p="${idx[p]}"

    i="$[n + $(printf "%d" "0x${md5:p:1}")]"
		s="$(printf "%d" "0x${md5:i:2}")"
		y="$(printf "%x" "$[s*a]")"

		napi+="${y:${#y}-1:1}"
	done

  echo $napi
}

fork__hash() {
  local c md5

  for ((c=0; $c < ${#files[@]}; c++)); do
    md5="$(__gen_md5_sums "$c")" \
      && napi="$(__gen_napi_sums "$md5")"
    echo "$? $c $md5 $napi" >&4
  done

  echo bye >&4
}

fork__download() {
  local ret=0
  while read -a childARG; do
    test "${childARG[0]}" = "bye" && break

    __download "${childARG[@]}"
    childARG[0]=$?

    echo "${childARG[@]}" >&3
  done <&4

  echo bye >&3
}

napi_poll() {
# Tworzenie fifo (kolejka: "pierwszy wchodzi, pierwszy wychodzi")
# do komunikacji pomiędzy forkiem a rodzicem
# kierunek: hash --> main
  mkfifo "$CACHE/hash-download.fifo"
  exec 4<>"$CACHE/hash-download.fifo"

  mkfifo "$CACHE/download-main.fifo"
  exec 3<>"$CACHE/download-main.fifo"

  fork__hash     & childPID+=($!)
  fork__download & childPID+=($!)

  local _subext=""

  while read -a childARG; do
    test "${childARG[0]}" = "bye" && break

    if [ "${childARG[0]}" = "0" ]; then
      # Konwertowanie strony kodowej
      subcp_convert "${childARG[@]}" || napi_msg "${childARG[1]}" "$?"

      subeol_convert "${childARG[@]}"

      # Konwetowanie formatu napisów i/lub pobieranie rozszerzenia o ile subext ma prefix
      _subext="$(subfmt_convert "${childARG[@]}")" || napi_msg "${childARG[1]}" "$?"

      # Instalowanie napisów
      subext="${_subext:-"txt"}" sub_install "${childARG[@]}"
      childARG[0]=$?
    fi

    napi_msg "${childARG[1]}" "${childARG[0]}"
  done <&3
}



#-------------------------------------------------------------------------------
#  Pobieranie napisów
#-------------------------------------------------------------------------------

__download() {
  test "$1" = "0" || return $1
  local fid="$2" md5="$3" napi="$4"

  local dlcmd="$DLAGENT"
  local dlfile="$CACHE/_${md5}_${napi}.7z"
  local subfile="$CACHE/_${md5}_${napi}.sub"

	local url="http://napiprojekt.pl/unit_napisy/dl.php?l=${napi_lang:-"PL"}&f=${md5}&t=${napi}&v=other&kolejka=false&nick=${napi_nick}&pass=${napi_pass}&napios=posix"

  # POBIERANIE ARCHIWUM 7Z Z NAPISAMI
  # (niestety ograniczenia 7z sprawiają że musi być plik)
  if [[ $dlcmd = *%o* ]]; then
		dlcmd=${dlcmd//\%o/\"$dlfile\"}
  else
    return 254
	fi
  if [[ $dlcmd = *%u* ]]; then
		dlcmd=${dlcmd//\%u/\"$url\"}
	else
		dlcmd="$dlcmd \"$url\""
	fi

  local ret=0
	eval "$dlcmd || ret=\$?"
	if [ "$ret" != "0" ]; then
		test -f "$dlfile" && unlink "$dlfile"
		return 255
	fi

  # SPRAWDZANIE ZAWARTOŚCI POBRANEGO PLIKU
  ### czasami jest tam tekst typu "Przerwa techniczna"
  local dlfile_size="$(stat -c "%s" "$dlfile")"

  if [ "$dlfile_size" -le "200" ]; then
    local dlfile_mime="$(file \
      --brief \
      --exclude apptype \
      --exclude encoding \
      --exclude tokens \
      --exclude cdf \
      --exclude compress \
      --exclude elf \
      --exclude tar \
      --exclude soft \
      --mime-type \
      "$dlfile")"

    if [ "$dlfile_mime" = "text/plain" ]; then
      local dlfile_source="$(cat "$dlfile")"
      unlink "$dlfile"
      case "${dlfile_source,,}" in
        *"przerwa techniczna"*) return 200;;
        npc0) return 1;;
        *) return 201;;
      esac
    fi
  fi


  # ROZPAKOWYWANIE NAPISÓW
  "$BIN_7z" x -y -so -piBlm8NTigvru0Jr0 "$dlfile" > "$subfile" 2>/dev/null
  test -f "$dlfile" && unlink "$dlfile"

  # PLIK JEST PUSTY - BRAK NAPISÓW
  if ! [ -s "$subfile" ]; then
    unlink "$subfile"
    return 1
  fi

  return 0
}

subfmt_convert__subext_autodetect() {
  local subfile="$1" output

  if enabled "$subext_autodetect"; then
    output="$("$BIN_subotage" -gi "$subfile" 2>&1)"

    array__get_opt "${output%% *}" "${subfmt_supported[@]}" && return 0

    echo "$subext"
    return 100
  fi

  echo "$subext"
}

subfmt_convert() {
  local md5="$3" napi="$4"
  local subfile="$CACHE/_${md5}_${napi}.sub"
  local subftmp="$CACHE/_${md5}_${napi}.sub.tmp"
  local output i

  if [ -z "$subfmt_conv" ]; then
    subfmt_convert__subext_autodetect "$subfile"
    return $?
  fi

  output="$("$BIN_subotage" -i "$subfile" -o "$subftmp" -of "$subfmt_conv" 2>&1)"

  if [[ "$output" =~ "An error occured" ]]; then
    if ! [[ "$output" =~ "No convertion is needed" ]]; then
      subfmt_convert__subext_autodetect "$subfile"
      return 101
    fi
  else
    cat "$subftmp" > "$subfile"
  fi

  test -f "$subftmp" && unlink "$subftmp"

  enabled "$subext_autodetect" \
    && array__get_opt "$subfmt_conv" "${subfmt_supported[@]}" \
    || echo "$subext"

  return 0
}

subcp_convert() {
  test -n "$subcp_conv" || return 0
  local md5="$3" napi="$4"

  # LOKALIZACJE PLIKÓW
  local subfile="$CACHE/_${md5}_${napi}.sub"
  local subftmp="$CACHE/_${md5}_${napi}.sub.tmp"

  # KOPIA TYMCZASOWA ORYGINAŁU
  cat "$subfile" > "$subftmp" # return

  # DETEKCJA KONWERTOWANIA
  local subcp_conv_from=""
  local subcp_conv_to="$subcp_conv"
  local encodingtype="$(file \
        --brief \
        --mime-encoding \
        --exclude apptype \
        --exclude tokens \
        --exclude cdf \
        --exclude compress \
        --exclude elf \
        --exclude soft \
        --exclude tar \
        "${subftmp}")"

  if [ "$?" = "0" ] && [ -n "$encodingtype" ]; then
    case "${encodingtype,,}" in
      *utf*) subcp_conv_from="UTF8";;
      *iso*) subcp_conv_from="ISO-8859-2";;
      *ascii*) subcp_conv_to="";;
      *) subcp_conv_from="WINDOWS-1250";;
    esac
  else
    subcp_conv_to=""
    subcp_conv_from=""
  fi

  # PORÓWNYWANIE STRON KODOWYCH I ZAPIS
  #-------------------------------------
  # Schemat postępowania: sprawdź czy istnieje potrzeba konwertowania
  #   nie) tylko catnij
  #   tak) przekonwertuj do pliku i w razie błędu nadpisz catem
  test "$subcp_conv_to" != "$subcp_conv_from" \
    && "$BIN_iconv" -f "$subcp_conv_from" -t "$subcp_conv_to" > "$subfile" 2> /dev/null < "$subftmp" \
    || cat > "$subfile" 2> /dev/null < "$subftmp"

  unlink "$subftmp"

  return 0
}

subeol_convert() {
  local md5="$3" napi="$4"
  local subfile="$CACHE/_${md5}_${napi}.sub"

  case "${subeol_conv,,}" in
    u*|l*) sed 's/\r$\|$//g'   -i "$subfile";;
    d*|c*) sed 's/\r$\|$/\r/g' -i "$subfile";;
  esac || true
}

sub_install() {
  local fid="$2" md5="$3" napi="$4"

  local subfile="$CACHE/_${md5}_${napi}.sub"
  local npath="${files[$fid]%.*}"

  # ILITERACJA W NAZWIE W PRZYPADKU BRAKU PRZYWOLENIA NA NADPIS
  if [ -e "$npath.$subext" -a "$suboverwrite" == "0" ]; then
    local -i c
    for ((c=0; $c < 100; c++)); do
      test -f "$npath.$c.$subext" || break
    done
    npath="$npath.$c"
  fi

  cat "$subfile" > "$npath.$subext"

  # GDY PLIK JEST PUSTY
  if [ ! -s "$npath.$subext" ]; then
    unlink "$npath.$subext"
    return 3
  fi

  return 0
}


#-------------------------------------------------------------------------------
#  Sprawdzanie
#-------------------------------------------------------------------------------
#login_check() {
#  "http://www.napiprojekt.pl/users_check.php?nick=%s&pswd=%s"
#}

setup_iconv() {
  test -n "$subcp_conv" || return 0

  case "${subcp_conv,,}" in
    u*) subcp_conv="UTF8";;
    i*) subcp_conv="ISO-8859-2";;
    w*) subcp_conv="WINDOWS-1250";;
    *)
      subcp_conv=""
      warn "Nieobsługiwana strona kodowa dla subcp_conv, pomijam..."
      return 0
  esac

  if ! BIN_iconv="$(findbin iconv)"; then
    subcp_conv=""
    warn "Aby móc korzystać z opcji subcp_conv, zainstaluj iconv..."
  fi
}

setup_subotage() {
  test -n "$subfmt_conv" || enabled "$subext_autodetect" || return 0

  case "${subfmt_conv,,}" in
    f*)    subfmt_conv=fab;;
    mi*)   subfmt_conv=microdvd;;
    mp*)   subfmt_conv=mpl2;;
    subv*) subfmt_conv=subviewer;;
    subr*) subfmt_conv=subrip;;
    t*)    subfmt_conv=tmplayer;;
    "")    subfmt_conv="";;
    *)
      subfmt_conv=""
      warn "Nieobsługiwana format napisów dla subfmt_conv, pomijam..."
  esac

  if ! BIN_subotage="$(findbin subotage.sh subotage)"; then
    subfmt_conv=""
    subext_autodetect=0
    warn "Aby móc korzystać z opcji subfmt_conv, zainstaluj subotage..."
  fi
}

setup_7z() {
  if ! BIN_7z="$(findbin 7za 7z)"; then
    error "Aby móc rozpakować archiwum z napisami zainstaluj p7zip..."
  fi
}

findbin() {
  local line
  while [ -n "$1" ]; do
    while read -d: line; do
      if [ -x "$line/$1" ]; then
        echo "$line/$1"
        return 0
      fi
    done <<< "$PATH"
    shift
  done
  return 1
}

#-------------------------------------------------------------------------------
#  Główny kod / main()
#-------------------------------------------------------------------------------
# main() {

CACHE="$(mktemp -u -d -p "${XDG_CACHE_HOME:-"${HOME}/.cache"}/napi-bash/" $$.XXXX)"
mkdir -p "$CACHE"
USERBREAK=0

# Obsługa sygnałów / czyszczenie
trap 'kill ${childPID[@]} &> /dev/null; rm -rf "$CACHE"' EXIT
trap 'USERBREAK=1; kill ${childPID[@]} &> /dev/null; echo bye >&3; echo -ne "\n*** Przerwane przez użytkownika ***\n"' SIGINT

get_ARGV "${@}"
napi_poll    # { child > fifo } & { poll < fifo }
napi_raport

exit 0
# }
